export const createCleanupManager = () => { const timeouts = new Set(); const intervals = new Set(); const abortControllers = new Set(); const eventListeners = []; let hlsInstance = null; let videoElement = null; let isDestroyed = false; const registerTimeout = (timeoutId) => { if (isDestroyed) return timeoutId; timeouts.add(timeoutId); return timeoutId; }; const registerInterval = (intervalId) => { if (isDestroyed) return intervalId; intervals.add(intervalId); return intervalId; }; const registerAbortController = (controller) => { if (isDestroyed) return controller; abortControllers.add(controller); return controller; }; const registerEventListener = (target, event, handler, options = {}) => { if (isDestroyed) return; eventListeners.push({ target, event, handler, options }); target.addEventListener(event, handler, options); }; const registerHls = (hls) => { if (isDestroyed) return; hlsInstance = hls; }; const registerVideo = (video) => { if (isDestroyed) return; videoElement = video; }; const clearRegisteredTimeout = (timeoutId) => { if (timeouts.has(timeoutId)) { clearTimeout(timeoutId); timeouts.delete(timeoutId); } }; const clearRegisteredInterval = (intervalId) => { if (intervals.has(intervalId)) { clearInterval(intervalId); intervals.delete(intervalId); } }; const clearAllTimeouts = () => { timeouts.forEach(id => clearTimeout(id)); timeouts.clear(); }; const clearAllIntervals = () => { intervals.forEach(id => clearInterval(id)); intervals.clear(); }; const abortAllRequests = () => { abortControllers.forEach(controller => { try { controller.abort(); } catch (e) {} }); abortControllers.clear(); }; const removeAllEventListeners = () => { eventListeners.forEach(({ target, event, handler, options }) => { try { target.removeEventListener(event, handler, options); } catch (e) {} }); eventListeners.length = 0; }; const destroyHls = () => { if (hlsInstance) { try { hlsInstance.destroy(); } catch (e) {} hlsInstance = null; } }; const clearVideo = () => { if (videoElement) { try { videoElement.pause(); videoElement.src = ""; videoElement.load(); } catch (e) {} videoElement = null; } }; const cleanup = () => { if (isDestroyed) return; isDestroyed = true; clearAllTimeouts(); clearAllIntervals(); abortAllRequests(); removeAllEventListeners(); destroyHls(); clearVideo(); }; const isCleanedUp = () => isDestroyed; const getResourceCounts = () => ({ timeouts: timeouts.size, intervals: intervals.size, abortControllers: abortControllers.size, eventListeners: eventListeners.length, hasHls: hlsInstance !== null, hasVideo: videoElement !== null, }); return { registerTimeout, registerInterval, registerAbortController, registerEventListener, registerHls, registerVideo, clearRegisteredTimeout, clearRegisteredInterval, clearAllTimeouts, clearAllIntervals, abortAllRequests, removeAllEventListeners, destroyHls, clearVideo, cleanup, isCleanedUp, getResourceCounts, }; }; export const combineCleanups = (...cleanupFns) => { return () => { cleanupFns.forEach(fn => { if (typeof fn === "function") { try { fn(); } catch (e) { console.warn("Cleanup error:", e); } } }); }; }; export const createSafeTimeout = (callback, delay, cleanupManager = null) => { const timeoutId = setTimeout(callback, delay); if (cleanupManager) cleanupManager.registerTimeout(timeoutId); return { timeoutId, clear: () => { clearTimeout(timeoutId); if (cleanupManager) cleanupManager.clearRegisteredTimeout(timeoutId); }, }; }; export const createSafeInterval = (callback, delay, cleanupManager = null) => { const intervalId = setInterval(callback, delay); if (cleanupManager) cleanupManager.registerInterval(intervalId); return { intervalId, clear: () => { clearInterval(intervalId); if (cleanupManager) cleanupManager.clearRegisteredInterval(intervalId); }, }; }; export const createSafeAbortController = (cleanupManager = null) => { const controller = new AbortController(); if (cleanupManager) cleanupManager.registerAbortController(controller); return controller; }; export default { createCleanupManager, combineCleanups, createSafeTimeout, createSafeInterval, createSafeAbortController, };
